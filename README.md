# OSIF_Revised

OSIF-Revised is a modified version of the [Open Source Impedance Fitter (OSIF)](https://github.com/NREL/OSIF) originally developed by NREL. This revision is customized for calculating the catalyst layer resistance (Rcl) for the Membrane Electrode Assembly (MEA) in water electrolysis applications. The main goals were to simplify the fitting model for our data and to enhance robustness during parameter error estimation.

## Overview

This software is a Python-based GUI application (using Tkinter) for fitting electrochemical impedance spectroscopy (EIS) data. The revised code focuses on accurately determining Rcl for water electrolysis MEA while streamlining the model and addressing certain numerical issues.

## Main Modifications

1. **Simplified Model (Neglect Lwire):**  
   In our EIS datasets no high-frequency inductive loop is observed. In the original OSIF model, the term
   
   $L_{\text{wire}}(j\omega)^{\theta}$
   
   is included. We have removed this term (by setting $\(L_{\text{wire}} = 0\)$ and the exponent $\(\theta = 0\))$ so that the fitting is not misled by non-existent inductive behavior and the progress is significantly faster.

3. **Robust Error Estimation for Singular Matrices:**  
   The original error estimation used the direct inverse of the Hessian approximation computed as follows:
   > **Original Code Snippet:**
   > 
   > ```python
   > Jacob = finalOutput.jac
   > estVars = np.matrix.diagonal(
   >     np.linalg.inv(Jacob.T.dot(Jacob)) * (np.matmul(np.transpose(finalOutput.fun), finalOutput.fun)) / (
   >     finalOutput.fun.shape[0] - self.finalParams.size))
   > ```
   This approach fails when the Hessian (i.e. \(J^T J\)) is singular. We revised this part by using a try/except block to check for singularity. If the Hessian is singular, the code now uses the pseudo-inverse, allowing the process to proceed even if some parameter error estimates may be less reliable.
   > **Revised Code Snippet:**
   > 
   > ```python
   > Jacob = finalOutput.jac
   > try:
   >     hessian_approx = Jacob.T @ Jacob
   >     cov_matrix = np.linalg.inv(hessian_approx)
   >     print("Jacobian is full-rank. Using regular inverse.")
   > except np.linalg.LinAlgError:
   >     print("Warning: Hessian matrix is singular — using pseudo-inverse instead.")
   >     tkMessageBox.showwarning("Warning", "Jacobian matrix singular. Some parameter errors may be unreliable.")
   >     cov_matrix = np.linalg.pinv(hessian_approx)
   > dof = finalOutput.fun.shape[0] - len(finalOutput.x)
   > if dof <= 0:
   >     sigma_squared = 0
   >     print("Warning: Degrees of freedom <= 0.")
   >     tkMessageBox.showwarning("Warning", "Degrees of freedom <= 0. Check data points.")
   > else:
   >     sigma_squared = (finalOutput.fun.T @ finalOutput.fun) / dof
   > estVars = np.diag(cov_matrix * sigma_squared)
   > self.standardDeviation = np.sqrt(estVars)
   > ```
   This modification ensures that the least-squares fitting process can proceed even if %\(J^T J\)% is singular, with a proper warning to the user.

4. **Auto Frequency-Window Function:**  
   We added an automated frequency-window selection routine. This function automatically searches for an optimal frequency range that minimizes the average percent standard error (SE) for the critical parameters (Rmem and Rcl).  
   - The routine first “chops” the raw data according to the initial frequency window set in the GUI.
   - It then tests candidate sub-windows (using a grid-search approach) and computes a cost metric defined as the average percent SE for Rmem and Rcl.
   - A penalty factor is applied to candidate windows that use too few data points (since reducing N tends to increase SE due to fewer degrees of freedom).
   - Finally, the candidate window with the lowest adjusted cost is selected and displayed—all in one click.

## Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/HIshimmoo/OSIF-Revised.git
   ```
2. Install the required packages:
   ```bash
   pip install numpy scipy matplotlib openpyxl
   ```
   (Tkinter is included with most Python distributions.)

## Usage

Run the application with:
```bash
python OSIF_Revised.py
```
- Use the GUI to select a data directory and file.
- Set the initial frequency window (e.g., upper bound: 10000 Hz, lower bound: 10 Hz) and other parameters.
- Click Simulate to see if the initial guess is fine. Modifying the initial parameters till the simulated line gets close to your original data.
- Click the "Auto-Freq Window" button to automatically choose the optimal frequency window.
- Then use the Fit to perform the impedance analysis for water electrolysis MEA and calculate Rcl.

## Data Format

- The tool accepts tab-delimited text files and Excel files generated by standard EIS software.
- Data should include columns for frequency, real impedance (Z′), and imaginary impedance (Z″).

## Citation

If you use this code in your work, please cite the original OSIF GitHub repository ([NREL/OSIF](https://github.com/NREL/OSIF)) and note that this repository contains revisions specifically for water electrolysis MEA Rcl determination.
